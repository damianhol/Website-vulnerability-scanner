import r from"isomorphic-unfetch";function e(){return e=Object.assign?Object.assign.bind():function(r){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(r[n]=t[n])}return r},e.apply(this,arguments)}var t=["model"],n=/*#__PURE__*/function(){function n(r,e){void 0===e&&(e={}),this.apiKey=void 0,this.defaultOptions=void 0,this.apiKey=r,this.defaultOptions=e}var i=n.prototype;return i.fillMask=function(r,e){try{return Promise.resolve(this.request(r,e))}catch(r){return Promise.reject(r)}},i.summarization=function(r,e){try{return Promise.resolve(this.request(r,e)).then(function(r){return null==r?void 0:r[0]})}catch(r){return Promise.reject(r)}},i.questionAnswer=function(r,e){try{return Promise.resolve(this.request(r,e))}catch(r){return Promise.reject(r)}},i.tableQuestionAnswer=function(r,e){try{return Promise.resolve(this.request(r,e))}catch(r){return Promise.reject(r)}},i.textClassification=function(r,e){try{return Promise.resolve(this.request(r,e)).then(function(r){return null==r?void 0:r[0]})}catch(r){return Promise.reject(r)}},i.textGeneration=function(r,e){try{return Promise.resolve(this.request(r,e)).then(function(r){return null==r?void 0:r[0]})}catch(r){return Promise.reject(r)}},i.tokenClassification=function(r,e){try{var t=n.toArray;return Promise.resolve(this.request(r,e)).then(function(r){return t.call(n,r)})}catch(r){return Promise.reject(r)}},i.translation=function(r,e){try{return Promise.resolve(this.request(r,e)).then(function(r){return null==r?void 0:r[0]})}catch(r){return Promise.reject(r)}},i.zeroShotClassification=function(r,e){try{var t=n.toArray;return Promise.resolve(this.request(r,e)).then(function(r){return t.call(n,r)})}catch(r){return Promise.reject(r)}},i.conversational=function(r,e){try{return Promise.resolve(this.request(r,e))}catch(r){return Promise.reject(r)}},i.featureExtraction=function(r,e){try{return Promise.resolve(this.request(r,e))}catch(r){return Promise.reject(r)}},i.automaticSpeechRecognition=function(r,t){try{return Promise.resolve(this.request(r,e({},t,{binary:!0})))}catch(r){return Promise.reject(r)}},i.audioClassification=function(r,t){try{return Promise.resolve(this.request(r,e({},t,{binary:!0})))}catch(r){return Promise.reject(r)}},i.imageClassification=function(r,t){try{return Promise.resolve(this.request(r,e({},t,{binary:!0})))}catch(r){return Promise.reject(r)}},i.objectDetection=function(r,t){try{return Promise.resolve(this.request(r,e({},t,{binary:!0})))}catch(r){return Promise.reject(r)}},i.imageSegmentation=function(r,t){try{return Promise.resolve(this.request(r,e({},t,{binary:!0})))}catch(r){return Promise.reject(r)}},i.request=function(n,i){try{var o=this,s=e({},o.defaultOptions,i),u=n.model,c=function(r,e){if(null==r)return{};var t,n,i={},o=Object.keys(r);for(n=0;n<o.length;n++)e.indexOf(t=o[n])>=0||(i[t]=r[t]);return i}(n,t);return Promise.resolve(r("https://api-inference.huggingface.co/models/"+u,{headers:{Authorization:"Bearer "+o.apiKey},method:"POST",body:null!=i&&i.binary?n.data:JSON.stringify(e({},c,{options:s}))})).then(function(r){return!1===s.retry_on_error||503!==r.status||s.wait_for_model?Promise.resolve(r.json()).then(function(r){if(r.error)throw new Error(r.error);return r}):o.request(n,e({},s,{wait_for_model:!0}))})}catch(r){return Promise.reject(r)}},n.toArray=function(r){return Array.isArray(r)?r:[r]},n}();export{n as HuggingFace,n as default};
//# sourceMappingURL=index.module.js.map
